---
title: "Global prediction of soil saturated hydraulic conductivity using random forest in a Covariate-based Geo Transfer Functions (CoGTF) framework"
authors: 
date: "Surya Gupta, Tom Hengl, Peter Lehmann, Sara Bonetti, Dani Or"
output: 
  github_document:
    toc: true
---

Soil saturated hydraulic conductivity (Ksat) is one of the prominent soil hydraulic properties used in the modeling of land surface processes. Ksat is often derived using limited dataset and soil basic properties likely soil texture, bulk density) by means pedotransfer functions (PTFs). We propose here an integrated Predictive Soil Modeling (PSM) framework where soil variables are combined with RS-based covariates using the Random Forest method. We refer to this approach as the “Covariate-based Geo Transfer Functions” (CoGTF). Here, the objective of this report to show the methods used to develop the CoGTF with R code and stepwise description.   


SoilKsatDB [link](https://doi.org/10.5281/zenodo.3752721)

CoGTF global Ksat maps [link](https://doi.org/10.5281/zenodo.3934853)

To cite this maps please use:

Gupta, S., Hengl, T., Lehmann, P., Bonetti, S., Papritz, A. and Or, D.: [Global prediction of soil saturated hydraulic conductivity using random forest in a Covariate-based Geo Transfer Functions (CoGTF) framework](https://www.essoar.org/doi/10.1002/essoar.10503663.1). manuscript submitted to Journal of Advances in Modeling Earth Systems (JAMES).


```{r}
library(caret)
library(randomForest)
library(ranger)
library(mlr)
library(tibble)
library(raster)
library(sp)
library(rgdal)
library(hexbin)
library(lattice)
library(RColorBrewer)
library(viridis)
library(Metrics)

ksat_df<-read.csv("E:/Ksat_dataset_mapping.csv")

## Unique IDs for 1 degrees by 1 degrees

## Spatial ID:
pol.100km = readOGR("E:/Ksat/tiles_ll_100km_mask.shp")
sp.pnts = ksat_df[,c("longitude_decimal_degrees", "latitude_decimal_degrees")]
ov.ID = sp::over(SpatialPoints(sp.pnts, proj4string = CRS(proj4string(pol.100km))), pol.100km["ID"])
summary(is.na(ov.ID$ID))
ksat_df$ID = ov.ID$ID


source("E:/OpenLandMap/R/saveRDS_functions.R")
source("E:/OpenLandMap/R/LandGIS_functions.R")

## saveRDS_functions.R and LandGIS_functions.R available at https://github.com/Envirometrix/LandGISmaps/tree/477460d1d0099646c508f65e68769b9edf050ce8/functions

## 3D modeling (see Hengl, T., & MacMillan, R. A. (2019). Predictive soil mapping with R. Lulu. com.)

dfs <- hor2xyd(ksat_df, U="hzn_top", L="hzn_bot")


I.vars = make.names(unique(unlist(sapply(c("s.no","clm_", "dtm_", "lcv", "veg_", "olm_c", "olm_s", "olm_bd", "ID", "DEPTH"), function(i){names(dfs)[grep(i, names(dfs))]}))))

t.vars = c("log_ksat")
sel.n <- c(t.vars,I.vars)
sel.r <- complete.cases(dfs[,sel.n])
PTF_temp2 <- dfs[sel.r,sel.n]

unique(PTF_temp2$ID)

```

# Selection of Grids randomly for spatial cross-validation

```{r}

## We have a total of 289 grids that contain data. We have divided the samples into 57 grids for each set. 
##Set1
set.seed(17)
chosen <- sample(unique(PTF_temp2$ID), 57)

ff<-subset(PTF_temp2, ID %in% chosen)

final<-PTF_temp2[!(PTF_temp2$ID %in% ff$ID),]

set.seed(18)
chosen <- sample(unique(final$ID), 57)

ff1<-subset(final, ID %in% chosen)

final1<-final[!(final$ID %in% ff1$ID),]


set.seed(19)
chosen <- sample(unique(final1$ID), 57)

ff2<-subset(final1, ID %in% chosen)

final2<-final1[!(final1$ID %in% ff2$ID),]


set.seed(20)
chosen <- sample(unique(final2$ID), 57)

ff3<-subset(final2, ID %in% chosen)

final3<-final2[!(final2$ID %in% ff3$ID),]



df1<-ff
df2<-ff1
df3<-ff2
df4<-ff3
df5<-final3


Train1<- rbind(ff, ff1, ff2, ff3)

Train2<- rbind (ff1, ff2, ff3,final3)

Train3<- rbind(ff2, ff3,final3, ff)

Train4<- rbind(ff3,final3, ff,ff1)

Train5<- rbind(final3, ff,ff1, ff2)

```
# Selection of Covaraites

```{r}
grid <- list.files("E:/maps_tests/new_layers/layers_RS/" , pattern = "*.tif$")
All_cov <- raster::stack(paste0("E:/maps_tests/new_layers/layers_RS/", grid))

set.seed(2) 
fm.ksat <- as.formula(paste("log_ksat~ ",paste(names(All_cov), collapse = "+")))
fm.ksat

```
# Model fitting
```{r}
set.seed(2) 
rm.ksat <- Train1[complete.cases(Train1[,all.vars(fm.ksat)]),]
m.ksat <- ranger(fm.ksat, rm.ksat, num.trees=200, mtry=6, quantreg = TRUE)
m.ksat

df5$prediction<- predict(m.ksat,df5)$predictions

RMSE(df5$prediction, df5$log_ksat)

## Ist_part is computed

rm.ksat1 <- Train2[complete.cases(Train2[,all.vars(fm.ksat)]),]
m.ksat1 <- ranger(fm.ksat, rm.ksat1, num.trees=200, mtry=6, quantreg = TRUE)
m.ksat1

df1$prediction<- predict(m.ksat1,df1)$predictions

RMSE(df1$prediction, df1$log_ksat)

## 2nd_part is computed
rm.ksat2 <- Train3[complete.cases(Train3[,all.vars(fm.ksat)]),]
m.ksat2 <- ranger(fm.ksat, rm.ksat2, num.trees=200, mtry=6, quantreg = TRUE)
m.ksat2

df2$prediction<- predict(m.ksat2,df2)$predictions

RMSE(df2$prediction, df2$log_ksat)

## 3rd_part is computed

rm.ksat3 <- Train4[complete.cases(Train4[,all.vars(fm.ksat)]),]
m.ksat3 <- ranger(fm.ksat, rm.ksat3, num.trees=200, mtry=6, quantreg = TRUE)
m.ksat3
df3$prediction<- predict(m.ksat3,df3)$predictions

RMSE(df3$prediction, df3$log_ksat)

## 4th_part is computed
rm.ksat4 <- Train5[complete.cases(Train5[,all.vars(fm.ksat)]),]
m.ksat4 <- ranger(fm.ksat, rm.ksat4, num.trees=200, mtry=6, quantreg = TRUE)
m.ksat4

df4$prediction<- predict(m.ksat4,df4)$predictions

RMSE(df4$prediction, df4$log_ksat)

Final_data<- rbind(df1,df2,df3,df4,df5)

#dd<- aggregate(Final_data[, 1:34], list(Final_data$s.no), mean)



ll<- lm(Final_data$prediction~ Final_data$log_ksat)

RMSE(Final_data$prediction,Final_data$log_ksat)

summary(ll)


ccc = DescTools::CCC(Final_data$prediction,Final_data$log_ksat, ci = "z-transform", conf.level = 0.95, na.rm=TRUE)$rho.c
ccc


Final_data$log_ksat1<- 10^Final_data$log_ksat
Final_data$prediction1<- 10^Final_data$prediction

hexbinplot(log_ksat1~ prediction1, 
           panel = function(x, y, ...){
             panel.hexbinplot(x, y, ...)
             panel.loess(x, y,span = 2/3, col.line = "blue",type="l", lty=2, lwd = 4)
             panel.abline(c(0, 1),lwd = 2)
           },
           data = Final_data,xlab = "Predicted Ksat [cm/day]", ylab = "Measured Ksat [cm/day]",cex.axis = 4, aspect="1", xbins=30, colramp = function(n) {viridis (8,  alpha = 1, begin = 0, end = 1, direction = -1,option = "C")},xlim=c(0.1,10000), ylim=c(0.1,10000),
           scales=list(
             x = list(log = 10, equispaced.log = FALSE), 
             y = list(log = 10, equispaced.log = FALSE)
           ),
           font.lab= 6, cex.labels = 1.2,font.axis = 2,colorcut=c(0,0.01,0.03,0.07,0.15,0.25,0.5,0.75,1) )


##Fitting final model

#rm.ksat <- PTF_temp2[complete.cases(PTF_temp2[,all.vars(fm.ksat)]),]
#m.ksat <- ranger(fm.ksat, rm.ksat, num.trees=200, mtry=6, quantreg = TRUE)
#m.ksat


##Importance variable
#m.ksat <- randomForest(fm.ksat, rm.ksat, num.trees=200, mtry=6, quantreg = TRUE)

#varImpPlot(m.ksat, sort=TRUE, n.var=min(30, nrow(m.ksat$importance)))

## Then Produced the final CoGTF map

#p2 = predict(All_cov,m.ksat, progress='window',type = "response",fun = function(model, ...) predict(model, ...)$predictions)

#writeRaster(p2, "/home/step/data/OpenLandMap/Final_selected_covariates/New_raster_layer/Final_RF_0cm.tif")

```

